\label{index_top}%
\Hypertarget{index_top}%
 \hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md163}{}\doxysection{Matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md163}
{\bfseries{Contents}}~\newline
 Using Matchers~\newline
 Built-\/in matchers~\newline
 Writing custom matchers (old style)~\newline
 Writing custom matchers (new style)~\newline


Matchers, as popularized by the \href{https://en.wikipedia.org/wiki/Hamcrest}{\texttt{ Hamcrest}} framework are an alternative way to write assertions, useful for tests where you work with complex types or need to assert more complex properties. Matchers are easily composable and users can write their own and combine them with the Catch2-\/provided matchers seamlessly.\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md164}{}\doxysubsection{Using Matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md164}
Matchers are most commonly used in tandem with the {\ttfamily REQUIRE\+\_\+\+THAT} or {\ttfamily CHECK\+\_\+\+THAT} macros. The {\ttfamily REQUIRE\+\_\+\+THAT} macro takes two arguments, the first one is the input (object/value) to test, the second argument is the matcher itself.

For example, to assert that a string ends with the \char`\"{}as a service\char`\"{} substring, you can write the following assertion


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }\mbox{\hyperlink{catch__amalgamated_8cpp_aee26f4e3f2ca725a42d7b1db56654fa4}{Catch::Matchers::EndsWith}};}
\DoxyCodeLine{}
\DoxyCodeLine{REQUIRE\_THAT(\ getSomeString(),\ \mbox{\hyperlink{catch__amalgamated_8cpp_aee26f4e3f2ca725a42d7b1db56654fa4}{EndsWith}}(\textcolor{stringliteral}{"{}as\ a\ service"{}})\ );}

\end{DoxyCode}


Individual matchers can also be combined using the C++ logical operators, that is {\ttfamily \&\&}, {\ttfamily $\vert$$\vert$}, and {\ttfamily !}, like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }\mbox{\hyperlink{catch__amalgamated_8cpp_aee26f4e3f2ca725a42d7b1db56654fa4}{Catch::Matchers::EndsWith}};}
\DoxyCodeLine{\textcolor{keyword}{using\ }\mbox{\hyperlink{catch__amalgamated_8cpp_a4d2b025a4c734b1f22ea3db83e9d6c92}{Catch::Matchers::ContainsSubstring}};}
\DoxyCodeLine{}
\DoxyCodeLine{REQUIRE\_THAT(\ getSomeString(),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{catch__amalgamated_8cpp_aee26f4e3f2ca725a42d7b1db56654fa4}{EndsWith}}(\textcolor{stringliteral}{"{}as\ a\ service"{}})\ \&\&\ \mbox{\hyperlink{catch__amalgamated_8cpp_a4d2b025a4c734b1f22ea3db83e9d6c92}{ContainsSubstring}}(\textcolor{stringliteral}{"{}web\ scale"{}}));}

\end{DoxyCode}


The example above asserts that the string returned from {\ttfamily get\+Some\+String} {\itshape both} ends with the suffix \char`\"{}as a service\char`\"{} {\itshape and} contains the string \char`\"{}web scale\char`\"{} somewhere.

Both of the string matchers used in the examples above live in the {\ttfamily catch\+\_\+matchers\+\_\+string.\+hpp} header, so to compile the code above also requires {\ttfamily \#include \texorpdfstring{$<$}{<}catch2/matchers/catch\+\_\+matchers\+\_\+string.\+hpp\texorpdfstring{$>$}{>}}.

{\bfseries{IMPORTANT}}\+: The combining operators do not take ownership of the matcher objects being combined. This means that if you store combined matcher object, you have to ensure that the matchers being combined outlive its last use. What this means is that the following code leads to a use-\/after-\/free (UAF)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/catch\_test\_macros.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/matchers/catch\_matchers\_string.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Bugs,\ bugs,\ bugs"{}},\ \textcolor{stringliteral}{"{}[Bug]"{}})\{}
\DoxyCodeLine{\ \ \ \ std::string\ \mbox{\hyperlink{classstr}{str}}\ =\ \textcolor{stringliteral}{"{}Bugs\ as\ a\ service"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ match\_expression\ =\ \mbox{\hyperlink{catch__amalgamated_8cpp_aee26f4e3f2ca725a42d7b1db56654fa4}{Catch::Matchers::EndsWith}}(\ \textcolor{stringliteral}{"{}as\ a\ service"{}}\ )\ ||}
\DoxyCodeLine{\ \ \ \ \ \ \ \ (\mbox{\hyperlink{catch__amalgamated_8cpp_aa830bf8902f231a7df15c13f81d0e268}{Catch::Matchers::StartsWith}}(\ \textcolor{stringliteral}{"{}Big\ data"{}}\ )\ \&\&\ !\mbox{\hyperlink{catch__amalgamated_8cpp_a4d2b025a4c734b1f22ea3db83e9d6c92}{Catch::Matchers::ContainsSubstring}}(\ \textcolor{stringliteral}{"{}web\ scale"{}}\ )\ );}
\DoxyCodeLine{\ \ \ \ REQUIRE\_THAT(\mbox{\hyperlink{classstr}{str}},\ match\_expression);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md165}{}\doxysubsection{Built-\/in matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md165}
Every matcher provided by Catch2 is split into 2 parts, a factory function that lives in the {\ttfamily Catch\+::\+Matchers} namespace, and the actual matcher type that is in some deeper namespace and should not be used by the user. In the examples above, we used {\ttfamily \doxylink{catch__amalgamated_8hpp_a057dc1a49cb5aef983e293c86816c239}{Catch\+::\+Matchers\+::\+Contains}}. This is the factory function for the {\ttfamily \doxylink{struct_catch_1_1_matchers_1_1_std_string_1_1_contains_matcher}{Catch\+::\+Matchers\+::\+Std\+String\+::\+Contains\+Matcher}} type that does the actual matching.

Out of the box, Catch2 provides the following matchers\+:\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md166}{}\doxysubsubsection{$<$tt$>$std\+::string$<$/tt$>$ matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md166}
Catch2 provides 5 different matchers that work with {\ttfamily std\+::string},
\begin{DoxyItemize}
\item {\ttfamily Starts\+With(std\+::string str, Case\+Sensitive)},
\item {\ttfamily Ends\+With(std\+::string str, Case\+Sensitive)},
\item {\ttfamily Contains\+Substring(std\+::string str, Case\+Sensitive)},
\item {\ttfamily Equals(std\+::string str, Case\+Sensitive)}, and
\item {\ttfamily Matches(std\+::string str, Case\+Sensitive)}.
\end{DoxyItemize}

The first three should be fairly self-\/explanatory, they succeed if the argument starts with {\ttfamily str}, ends with {\ttfamily str}, or contains {\ttfamily str} somewhere inside it.

The {\ttfamily Equals} matcher matches a string if (and only if) the argument string is equal to {\ttfamily str}.

Finally, the {\ttfamily Matches} matcher performs an ECMAScript regex match using {\ttfamily str} against the argument string. It is important to know that the match is performed against the string as a whole, meaning that the regex {\ttfamily \char`\"{}abc\char`\"{}} will not match input string {\ttfamily \char`\"{}abcd\char`\"{}}. To match {\ttfamily \char`\"{}abcd\char`\"{}}, you need to use e.\+g. {\ttfamily \char`\"{}abc.$\ast$\char`\"{}} as your regex.

The second argument sets whether the matching should be case-\/sensitive or not. By default, it is case-\/sensitive.

\begin{quote}
{\ttfamily std\+::string} matchers live in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+string.\+hpp} \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md167}{}\doxysubsubsection{Vector matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md167}
{\itshape Vector matchers have been deprecated in favour of the generic range matchers with the same functionality.}

Catch2 provides 5 built-\/in matchers that work on {\ttfamily std\+::vector}.

These are


\begin{DoxyItemize}
\item {\ttfamily Contains} which checks whether a specified vector is present in the result
\item {\ttfamily Vector\+Contains} which checks whether a specified element is present in the result
\item {\ttfamily Equals} which checks whether the result is exactly equal (order matters) to a specific vector
\item {\ttfamily Unordered\+Equals} which checks whether the result is equal to a specific vector under a permutation
\item {\ttfamily Approx} which checks whether the result is \char`\"{}approx-\/equal\char`\"{} (order matters, but comparison is done via {\ttfamily Approx}) to a specific vector \begin{quote}
Approx matcher was \href{https://github.com/catchorg/Catch2/issues/1499}{\texttt{ introduced}} in Catch2 2.\+7.\+2. \end{quote}
An example usage\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ some\_vec\{\ 1,\ 2,\ 3\ \};}
\DoxyCodeLine{REQUIRE\_THAT(some\_vec,\ Catch::Matchers::UnorderedEquals(std::vector<int>\{\ 3,\ 2,\ 1\ \}));}

\end{DoxyCode}

\end{DoxyItemize}

This assertions will pass, because the elements given to the matchers are a permutation of the ones in {\ttfamily some\+\_\+vec}.

\begin{quote}
vector matchers live in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+vector.\+hpp} \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md168}{}\doxysubsubsection{Floating point matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md168}
Catch2 provides 3 matchers that target floating point numbers. These are\+:


\begin{DoxyItemize}
\item {\ttfamily Within\+Abs(double target, double margin)},
\item {\ttfamily Within\+ULP(\+Floating\+Point target, uint64\+\_\+t max\+Ulp\+Diff)}, and
\item {\ttfamily Within\+Rel(\+Floating\+Point target, Floating\+Point eps)}.
\end{DoxyItemize}

\begin{quote}
{\ttfamily Within\+Rel} matcher was introduced in Catch2 2.\+10.\+0 \end{quote}


{\ttfamily Within\+Abs} creates a matcher that accepts floating point numbers whose difference with {\ttfamily target} is less than the {\ttfamily margin}.

{\ttfamily Within\+ULP} creates a matcher that accepts floating point numbers that are no more than {\ttfamily max\+Ulp\+Diff} \href{https://en.wikipedia.org/wiki/Unit_in_the_last_place}{\texttt{ ULPs}} away from the {\ttfamily target} value. The short version of what this means is that there is no more than {\ttfamily max\+Ulp\+Diff -\/ 1} representeable floating point numbers between the argument for matching and the {\ttfamily target} value.

{\bfseries{Important}}\+: The Within\+ULP matcher requires the platform to use the \href{https://en.wikipedia.org/wiki/IEEE_754}{\texttt{ IEEE-\/754}} representation for floating point numbers.

{\ttfamily Within\+Rel} creates a matcher that accepts floating point numbers that are {\itshape approximately equal} with the {\ttfamily target} with tolerance of {\ttfamily eps.} Specifically, it matches if {\ttfamily $\vert$arg -\/ target$\vert$ \texorpdfstring{$<$}{<}= eps $\ast$ max($\vert$arg$\vert$, $\vert$target$\vert$)} holds. If you do not specify {\ttfamily eps}, {\ttfamily std\+::numeric\+\_\+limits\texorpdfstring{$<$}{<}Floating\+Point\texorpdfstring{$>$}{>}::epsilon $\ast$ 100} is used as the default.

In practice, you will often want to combine multiple of these matchers, together for an assertion, because all 3 options have edge cases where they behave differently than you would expect. As an example, under the {\ttfamily Within\+Rel} matcher, a {\ttfamily 0.} only ever matches a {\ttfamily 0.} (or {\ttfamily -\/0.}), regardless of the relative tolerance specified. Thus, if you want to handle numbers that are \char`\"{}close enough to 0 to be 0\char`\"{}, you have to combine it with the {\ttfamily Within\+Abs} matcher.

For example, to check that our computation matches known good value within 0.\+1\%, or is close enough (no different to 5 decimal places) to zero, we would write this assertion\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THAT(\ computation(input),}
\DoxyCodeLine{\ \ \ \ Catch::Matchers::WithinRel(expected,\ 0.001)}
\DoxyCodeLine{\ ||\ Catch::Matchers::WithinAbs(0,\ 0.000001)\ );}

\end{DoxyCode}


\begin{quote}
floating point matchers live in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+floating.\+hpp} \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md169}{}\doxysubsubsection{Miscellaneous matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md169}
Catch2 also provides some matchers and matcher utilities that do not quite fit into other categories.

The first one of them is the {\ttfamily Predicate(\+Callable pred, std\+::string description)} matcher. It creates a matcher object that calls {\ttfamily pred} for the provided argument. The {\ttfamily description} argument allows users to set what the resulting matcher should self-\/describe as if required.

Do note that you will need to explicitly specify the type of the argument, like in this example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THAT(\textcolor{stringliteral}{"{}Hello\ olleH"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ Predicate<std::string>(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ []\ (std::string\ \textcolor{keyword}{const}\&\ \mbox{\hyperlink{classstr}{str}})\ -\/>\ \textcolor{keywordtype}{bool}\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{classstr}{str}}.front()\ ==\ \mbox{\hyperlink{classstr}{str}}.back();\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}First\ and\ last\ character\ should\ be\ equal"{}})}
\DoxyCodeLine{);}

\end{DoxyCode}


\begin{quote}
the predicate matcher lives in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+predicate.\+hpp} \end{quote}


The other miscellaneous matcher utility is exception matching.\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md170}{}\doxyparagraph{Matching exceptions}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md170}
Catch2 provides an utility macro for asserting that an expression throws exception of specific type, and that the exception has desired properties. The macro is {\ttfamily REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES(expr, Exception\+Type, Matcher)}.

\begin{quote}
{\ttfamily REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES} macro lives in {\ttfamily catch2/matchers/catch\+\_\+matchers.\+hpp} \end{quote}


Catch2 currently provides only one matcher for exceptions, {\ttfamily Message(std\+::string message)}. {\ttfamily Message} checks that the exception\textquotesingle{}s message, as returned from {\ttfamily what} is exactly equal to {\ttfamily message}.

\doxylink{struct_example}{Example} use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THROWS\_MATCHES(throwsDerivedException(),\ \ DerivedException,\ \ \mbox{\hyperlink{catch__amalgamated_8cpp_a1df1bdfb43e07bfae40e127eb1987c7a}{Message}}(\textcolor{stringliteral}{"{}DerivedException::what"{}}));}

\end{DoxyCode}


Note that {\ttfamily Derived\+Exception} in the example above has to derive from {\ttfamily std\+::exception} for the example to work.

\begin{quote}
the exception message matcher lives in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+exception.\+hpp} \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md171}{}\doxysubsubsection{Generic range Matchers}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md171}
\begin{quote}
Generic range matchers were introduced in Catch2 X.\+Y.\+Z \end{quote}
Catch2 also provides some matchers that use the new style matchers definitions to handle generic range-\/like types. These are\+:


\begin{DoxyItemize}
\item {\ttfamily Is\+Empty()}
\item {\ttfamily Size\+Is(size\+\_\+t target\+\_\+size)}
\item {\ttfamily Size\+Is(\+Matcher size\+\_\+matcher)}
\item {\ttfamily Contains(T\&\& target\+\_\+element, Comparator = std\+::equal\+\_\+to\texorpdfstring{$<$}{<}\texorpdfstring{$>$}{>}\{\})}
\item {\ttfamily Contains(\+Matcher element\+\_\+matcher)}
\end{DoxyItemize}

{\ttfamily Is\+Empty} should be self-\/explanatory. It successfully matches objects that are empty according to either {\ttfamily std\+::empty}, or ADL-\/found {\ttfamily empty} free function.

{\ttfamily Size\+Is} checks range\textquotesingle{}s size. If constructed with {\ttfamily size\+\_\+t} arg, the matchers accepts ranges whose size is exactly equal to the arg. If constructed from another matcher, then the resulting matcher accepts ranges whose size is accepted by the provided matcher.

{\ttfamily Contains} accepts ranges that contain specific element. There are again two variants, one that accepts the desired element directly, in which case a range is accepted if any of its elements is equal to the target element. The other variant is constructed from a matcher, in which case a range is accepted if any of its elements is accepted by the provided matcher.\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md172}{}\doxysubsection{Writing custom matchers (old style)}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md172}
The old style of writing matchers has been introduced back in Catch Classic. To create an old-\/style matcher, you have to create your own type that derives from {\ttfamily \doxylink{struct_catch_1_1_matchers_1_1_matcher_base}{Catch\+::\+Matchers\+::\+Matcher\+Base}\texorpdfstring{$<$}{<}ArgT\texorpdfstring{$>$}{>}}, where {\ttfamily ArgT} is the type your matcher works for. Your type has to override two methods, {\ttfamily bool match(ArgT const\&) const}, and {\ttfamily std\+::string describe() const}.

As the name suggests, {\ttfamily match} decides whether the provided argument is matched (accepted) by the matcher. {\ttfamily describe} then provides a human-\/oriented description of what the matcher does.

We also recommend that you create factory function, just like Catch2 does, but that is mostly useful for template argument deduction for templated matchers (assuming you do not have CTAD available).

To combine these into an example, let\textquotesingle{}s say that you want to write a matcher that decides whether the provided argument is a number within certain range. We will call it {\ttfamily Is\+Between\+Matcher\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/catch\_test\_macros.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/matchers/catch\_matchers.hpp>}}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{class\ }IsBetweenMatcher\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_matcher_base}{Catch::Matchers::MatcherBase}}<T>\ \{}
\DoxyCodeLine{\ \ \ \ T\ m\_begin,\ m\_end;}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ IsBetweenMatcher(T\ begin,\ T\ end)\ :\ m\_begin(begin),\ m\_end(end)\ \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ match(T\ \textcolor{keyword}{const}\&\ in)\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ in\ >=\ m\_begin\ \&\&\ in\ <=\ m\_end;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::string\ describe()\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::ostringstream\ ss;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}is\ between\ "{}}\ <<\ m\_begin\ <<\ \textcolor{stringliteral}{"{}\ and\ "{}}\ <<\ m\_end;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ss.str();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{IsBetweenMatcher<T>\ IsBetween(T\ begin,\ T\ end)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \{\ begin,\ end\ \};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Numbers\ are\ within\ range"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ infers\ \`{}double`\ for\ the\ argument\ type\ of\ the\ matcher}}
\DoxyCodeLine{\ \ \ \ CHECK\_THAT(3.,\ IsBetween(1.,\ 10.));}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ infers\ \`{}int`\ for\ the\ argument\ type\ of\ the\ matcher}}
\DoxyCodeLine{\ \ \ \ CHECK\_THAT(100,\ IsBetween(1,\ 10));}
\DoxyCodeLine{\}}

\end{DoxyCode}


Obviously, the code above can be improved somewhat, for example you might want to {\ttfamily static\+\_\+assert} over the fact that {\ttfamily T} is an arithmetic type... or generalize the matcher to cover any type for which the user can provide a comparison function object.

Note that while any matcher written using the old style can also be written using the new style, combining old style matchers should generally compile faster. Also note that you can combine old and new style matchers arbitrarily.

\begin{quote}
{\ttfamily Matcher\+Base} lives in {\ttfamily catch2/matchers/catch\+\_\+matchers.\+hpp} \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md173}{}\doxysubsection{Writing custom matchers (new style)}\label{md_ext_2hera_2extern_2_catch2_2docs_2matchers_autotoc_md173}
\begin{quote}
New style matchers were introduced in Catch2 X.\+Y.\+Z \end{quote}
To create a new-\/style matcher, you have to create your own type that derives from {\ttfamily \doxylink{struct_catch_1_1_matchers_1_1_matcher_generic_base}{Catch\+::\+Matchers\+::\+Matcher\+Generic\+Base}}. Your type has to also provide two methods, {\ttfamily bool match( ... ) const} and overriden {\ttfamily std\+::string describe() const}.

Unlike with old-\/style matchers, there are no requirements on how the {\ttfamily match} member function takes its argument. This means that the argument can be taken by value or by mutating reference, but also that the matcher\textquotesingle{}s {\ttfamily match} member function can be templated.

This allows you to write more complex matcher, such as a matcher that can compare one range-\/like (something that responds to {\ttfamily begin} and {\ttfamily end}) object to another, like in the following example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/catch\_test\_macros.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch2/matchers/catch\_matchers\_templated.hpp>}}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Range>}
\DoxyCodeLine{\textcolor{keyword}{struct\ }\mbox{\hyperlink{struct_equals_range_matcher}{EqualsRangeMatcher}}\ :\ \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_matcher_generic_base}{Catch::Matchers::MatcherGenericBase}}\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct_equals_range_matcher}{EqualsRangeMatcher}}(Range\ \textcolor{keyword}{const}\&\ range):}
\DoxyCodeLine{\ \ \ \ \ \ \ \ range\{\ range\ \}}
\DoxyCodeLine{\ \ \ \ \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ OtherRange>}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ match(OtherRange\ \textcolor{keyword}{const}\&\ other)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{using\ }std::begin;\ \textcolor{keyword}{using\ }std::end;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::equal(begin(range),\ end(range),\ begin(other),\ end(other));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::string\ describe()\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}Equals:\ "{}}\ +\ Catch::rangeToString(range);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ Range\ \textcolor{keyword}{const}\&\ range;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ Range>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ EqualsRange(\textcolor{keyword}{const}\ Range\&\ range)\ -\/>\ \mbox{\hyperlink{struct_equals_range_matcher}{EqualsRangeMatcher<Range>}}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{struct_equals_range_matcher}{EqualsRangeMatcher<Range>}}\{range\};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Combining\ templated\ matchers"{}},\ \textcolor{stringliteral}{"{}[matchers][templated]"{}})\ \{}
\DoxyCodeLine{\ \ \ \ std::array<int,\ 3>\ container\{\{\ 1,2,3\ \}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::array<int,\ 3>\ a\{\{\ 1,2,3\ \}\};}
\DoxyCodeLine{\ \ \ \ std::vector<int>\ b\{\ 0,1,2\ \};}
\DoxyCodeLine{\ \ \ \ std::list<int>\ c\{\ 4,5,6\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ REQUIRE\_THAT(container,\ EqualsRange(a)\ ||\ EqualsRange(b)\ ||\ EqualsRange(c));}
\DoxyCodeLine{\}}

\end{DoxyCode}


Do note that while you can rewrite any matcher from the old style to a new style matcher, combining new style matchers is more expensive in terms of compilation time. Also note that you can combine old style and new style matchers arbitrarily.

\begin{quote}
{\ttfamily Matcher\+Generic\+Base} lives in {\ttfamily catch2/matchers/catch\+\_\+matchers\+\_\+templated.\+hpp} \end{quote}


\DoxyHorRuler{0}


\href{Readme.md\#top}{\texttt{ Home}} 