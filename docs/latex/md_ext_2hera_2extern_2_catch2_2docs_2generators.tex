\label{index_top}%
\Hypertarget{index_top}%
 \hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md137}{}\doxysection{Data Generators}\label{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md137}
\begin{quote}
Introduced in Catch2 2.\+6.\+0. \end{quote}
\doxylink{struct_data}{Data} generators (also known as {\itshape data driven/parametrized test cases}) let you reuse the same set of assertions across different input values. In Catch2, this means that they respect the ordering and nesting of the {\ttfamily TEST\+\_\+\+CASE} and {\ttfamily SECTION} macros, and their nested sections are run once per each value in a generator.

This is best explained with an example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Generators"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ i\ =\ GENERATE(1,\ 3,\ 5);}
\DoxyCodeLine{\ \ \ \ REQUIRE(is\_odd(i));}
\DoxyCodeLine{\}}

\end{DoxyCode}


The \char`\"{}\+Generators\char`\"{} {\ttfamily TEST\+\_\+\+CASE} will be entered 3 times, and the value of {\ttfamily i} will be 1, 3, and 5 in turn. {\ttfamily GENERATE}s can also be used multiple times at the same scope, in which case the result will be a cartesian product of all elements in the generators. This means that in the snippet below, the test case will be run 6 (2$\ast$3) times.


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Generators"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ i\ =\ GENERATE(1,\ 2);}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ j\ =\ GENERATE(3,\ 4,\ 5);}
\DoxyCodeLine{\}}

\end{DoxyCode}


There are 2 parts to generators in Catch2, the {\ttfamily GENERATE} macro together with the already provided generators, and the {\ttfamily IGenerator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} interface that allows users to implement their own generators.\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md138}{}\doxysubsection{Combining $<$tt$>$\+GENERATE$<$/tt$>$ and $<$tt$>$\+SECTION$<$/tt$>$.}\label{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md138}
{\ttfamily GENERATE} can be seen as an implicit {\ttfamily SECTION}, that goes from the place {\ttfamily GENERATE} is used, to the end of the scope. This can be used for various effects. The simplest usage is shown below, where the {\ttfamily SECTION} \char`\"{}one\char`\"{} runs 4 (2$\ast$2) times, and {\ttfamily SECTION} \char`\"{}two\char`\"{} is run 6 times (2$\ast$3).


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Generators"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ i\ =\ GENERATE(1,\ 2);}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}one"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ j\ =\ GENERATE(-\/3,\ -\/2);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ REQUIRE(j\ <\ i);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}two"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ k\ =\ GENERATE(4,\ 5,\ 6);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ REQUIRE(i\ !=\ k);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


The specific order of the {\ttfamily SECTION}s will be \char`\"{}one\char`\"{}, \char`\"{}one\char`\"{}, \char`\"{}two\char`\"{}, \char`\"{}two\char`\"{}, \char`\"{}two\char`\"{}, \char`\"{}one\char`\"{}...

The fact that {\ttfamily GENERATE} introduces a virtual {\ttfamily SECTION} can also be used to make a generator replay only some {\ttfamily SECTION}s, without having to explicitly add a {\ttfamily SECTION}. As an example, the code below reports 3 assertions, because the \char`\"{}first\char`\"{} section is run once, but the \char`\"{}second\char`\"{} section is run twice.


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}GENERATE\ between\ SECTIONs"{}})\ \{}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}first"{}})\ \{\ REQUIRE(\textcolor{keyword}{true});\ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ \_\ =\ GENERATE(1,\ 2);}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}second"{}})\ \{\ REQUIRE(\textcolor{keyword}{true});\ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


This can lead to surprisingly complex test flows. As an example, the test below will report 14 assertions\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Complex\ mix\ of\ sections\ and\ generates"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ i\ =\ GENERATE(1,\ 2);}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}A"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SUCCEED(\textcolor{stringliteral}{"{}A"{}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ j\ =\ GENERATE(3,\ 4);}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}B"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SUCCEED(\textcolor{stringliteral}{"{}B"{}});}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ k\ =\ GENERATE(5,\ 6);}
\DoxyCodeLine{\ \ \ \ SUCCEED();}
\DoxyCodeLine{\}}

\end{DoxyCode}


\begin{quote}
The ability to place {\ttfamily GENERATE} between two {\ttfamily SECTION}s was \href{https://github.com/catchorg/Catch2/issues/1938}{\texttt{ introduced}} in Catch2 2.\+13.\+0. \end{quote}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md139}{}\doxysubsection{Provided generators}\label{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md139}
Catch2\textquotesingle{}s provided generator functionality consists of three parts,


\begin{DoxyItemize}
\item {\ttfamily GENERATE} macro, that serves to integrate generator expression with a test case,
\item 2 fundamental generators
\begin{DoxyItemize}
\item {\ttfamily Single\+Value\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- contains only single element
\item {\ttfamily Fixed\+Values\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- contains multiple elements
\end{DoxyItemize}
\item 5 generic generators that modify other generators
\begin{DoxyItemize}
\item {\ttfamily Filter\+Generator\texorpdfstring{$<$}{<}T, Predicate\texorpdfstring{$>$}{>}} -- filters out elements from a generator for which the predicate returns \char`\"{}false\char`\"{}
\item {\ttfamily Take\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- takes first {\ttfamily n} elements from a generator
\item {\ttfamily Repeat\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- repeats output from a generator {\ttfamily n} times
\item {\ttfamily Map\+Generator\texorpdfstring{$<$}{<}T, U, Func\texorpdfstring{$>$}{>}} -- returns the result of applying {\ttfamily Func} on elements from a different generator
\item {\ttfamily Chunk\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- returns chunks (inside {\ttfamily std\+::vector}) of n elements from a generator
\end{DoxyItemize}
\item 4 specific purpose generators
\begin{DoxyItemize}
\item {\ttfamily Random\+Integer\+Generator\texorpdfstring{$<$}{<}Integral\texorpdfstring{$>$}{>}} -- generates random Integrals from range
\item {\ttfamily Random\+Float\+Generator\texorpdfstring{$<$}{<}Float\texorpdfstring{$>$}{>}} -- generates random Floats from range
\item {\ttfamily Range\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(first, last)} -- generates all values inside a {\ttfamily \mbox{[}first, last)} arithmetic range
\item {\ttfamily Iterator\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -- copies and returns values from an iterator range
\end{DoxyItemize}
\end{DoxyItemize}

\begin{quote}
{\ttfamily Chunk\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}, {\ttfamily Random\+Integer\+Generator\texorpdfstring{$<$}{<}Integral\texorpdfstring{$>$}{>}}, {\ttfamily Random\+Float\+Generator\texorpdfstring{$<$}{<}Float\texorpdfstring{$>$}{>}} and {\ttfamily Range\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} were introduced in Catch2 2.\+7.\+0. \end{quote}
\begin{quote}
{\ttfamily Iterator\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} was introduced in Catch2 2.\+10.\+0. \end{quote}
The generators also have associated helper functions that infer their type, making their usage much nicer. These are


\begin{DoxyItemize}
\item {\ttfamily value(T\&\&)} for {\ttfamily Single\+Value\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily values(std\+::initializer\+\_\+list\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>})} for {\ttfamily Fixed\+Values\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily table\texorpdfstring{$<$}{<}Ts...\texorpdfstring{$>$}{>}(std\+::initializer\+\_\+list\texorpdfstring{$<$}{<}std\+::tuple\texorpdfstring{$<$}{<}Ts...\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>})} for {\ttfamily Fixed\+Values\+Generator\texorpdfstring{$<$}{<}std\+::tuple\texorpdfstring{$<$}{<}Ts...\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}
\item {\ttfamily filter(predicate, Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Filter\+Generator\texorpdfstring{$<$}{<}T, Predicate\texorpdfstring{$>$}{>}}
\item {\ttfamily take(count, Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Take\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily repeat(repeats, Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Repeat\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily map(func, Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Map\+Generator\texorpdfstring{$<$}{<}T, U, Func\texorpdfstring{$>$}{>}} (map {\ttfamily U} to {\ttfamily T}, deduced from {\ttfamily Func})
\item {\ttfamily map\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(func, Generator\+Wrapper\texorpdfstring{$<$}{<}U\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Map\+Generator\texorpdfstring{$<$}{<}T, U, Func\texorpdfstring{$>$}{>}} (map {\ttfamily U} to {\ttfamily T})
\item {\ttfamily chunk(chunk-\/size, Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\&\&)} for {\ttfamily Chunk\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily random(\+Integer\+Or\+Float a, Integer\+Or\+Float b)} for {\ttfamily Random\+Integer\+Generator} or {\ttfamily Random\+Float\+Generator}
\item {\ttfamily range(\+Arithemtic start, Arithmetic end)} for {\ttfamily Range\+Generator\texorpdfstring{$<$}{<}Arithmetic\texorpdfstring{$>$}{>}} with a step size of {\ttfamily 1}
\item {\ttfamily range(\+Arithmetic start, Arithmetic end, Arithmetic step)} for {\ttfamily Range\+Generator\texorpdfstring{$<$}{<}Arithmetic\texorpdfstring{$>$}{>}} with a custom step size
\item {\ttfamily from\+\_\+range(\+Input\+Iterator from, Input\+Iterator to)} for {\ttfamily Iterator\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\item {\ttfamily from\+\_\+range(Container const\&)} for {\ttfamily Iterator\+Generator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}
\end{DoxyItemize}

\begin{quote}
{\ttfamily chunk()}, {\ttfamily random()} and both {\ttfamily range()} functions were introduced in Catch2 2.\+7.\+0. \end{quote}
\begin{quote}
{\ttfamily from\+\_\+range} has been introduced in Catch2 2.\+10.\+0 \end{quote}
\begin{quote}
{\ttfamily range()} for floating point numbers has been introduced in Catch2 2.\+11.\+0 \end{quote}
And can be used as shown in the example below to create a generator that returns 100 odd random number\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Generating\ random\ ints"{}},\ \textcolor{stringliteral}{"{}[example][generator]"{}})\ \{}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}Deducing\ functions"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ i\ =\ GENERATE(take(100,\ filter([](\textcolor{keywordtype}{int}\ i)\ \{\ \textcolor{keywordflow}{return}\ i\ \%\ 2\ ==\ 1;\ \},\ random(-\/100,\ 100))));}
\DoxyCodeLine{\ \ \ \ \ \ \ \ REQUIRE(i\ >\ -\/100);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ REQUIRE(i\ <\ 100);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ REQUIRE(i\ \%\ 2\ ==\ 1);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Apart from registering generators with Catch2, the {\ttfamily GENERATE} macro has one more purpose, and that is to provide simple way of generating trivial generators, as seen in the first example on this page, where we used it as {\ttfamily auto i = GENERATE(1, 2, 3);}. This usage converted each of the three literals into a single {\ttfamily Single\+Value\+Generator\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}} and then placed them all in a special generator that concatenates other generators. It can also be used with other generators as arguments, such as {\ttfamily auto i = GENERATE(0, 2, take(100, random(300, 3000)));}. This is useful e.\+g. if you know that specific inputs are problematic and want to test them separately/first.

{\bfseries{For safety reasons, you cannot use variables inside the {\ttfamily GENERATE} macro. This is done because the generator expression {\itshape will} outlive the outside scope and thus capturing references is dangerous. If you need to use variables inside the generator expression, make sure you thought through the lifetime implications and use {\ttfamily GENERATE\+\_\+\+COPY} or {\ttfamily GENERATE\+\_\+\+REF}.}}

\begin{quote}
{\ttfamily GENERATE\+\_\+\+COPY} and {\ttfamily GENERATE\+\_\+\+REF} were introduced in Catch2 2.\+7.\+1. \end{quote}
You can also override the inferred type by using {\ttfamily as\texorpdfstring{$<$}{<}type\texorpdfstring{$>$}{>}} as the first argument to the macro. This can be useful when dealing with string literals, if you want them to come out as {\ttfamily std\+::string}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}type\ conversion"{}},\ \textcolor{stringliteral}{"{}[generators]"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ \mbox{\hyperlink{classstr}{str}}\ =\ GENERATE(as<std::string>\{\},\ \textcolor{stringliteral}{"{}a"{}},\ \textcolor{stringliteral}{"{}bb"{}},\ \textcolor{stringliteral}{"{}ccc"{}});}
\DoxyCodeLine{\ \ \ \ REQUIRE(\mbox{\hyperlink{classstr}{str}}.size()\ >\ 0);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md140}{}\doxysubsection{Generator interface}\label{md_ext_2hera_2extern_2_catch2_2docs_2generators_autotoc_md140}
You can also implement your own generators, by deriving from the {\ttfamily IGenerator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} interface\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{struct\ }IGenerator\ :\ GeneratorUntypedBase\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ via\ GeneratorUntypedBase:}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Attempts\ to\ move\ the\ generator\ to\ the\ next\ element.}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Returns\ true\ if\ successful\ (and\ thus\ has\ another\ element\ that\ can\ be\ read)}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ \textcolor{keywordtype}{bool}\ next()\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Precondition:}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ The\ generator\ is\ either\ freshly\ constructed\ or\ the\ last\ call\ to\ next()\ returned\ true}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ T\ \textcolor{keyword}{const}\&\ get()\ \textcolor{keyword}{const}\ =\ 0;}
\DoxyCodeLine{\};}

\end{DoxyCode}


However, to be able to use your custom generator inside {\ttfamily GENERATE}, it will need to be wrapped inside a {\ttfamily Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}. {\ttfamily Generator\+Wrapper\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} is a value wrapper around a {\ttfamily std\+::unique\+\_\+ptr\texorpdfstring{$<$}{<}IGenerator\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}.

For full example of implementing your own generator, look into Catch2\textquotesingle{}s examples, specifically \href{../examples/300-Gen-OwnGenerator.cpp}{\texttt{ Generators\+: Create your own generator}}. 